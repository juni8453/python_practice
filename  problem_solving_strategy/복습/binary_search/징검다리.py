def solution(distance, rocks, n):
    answer = -1e15
    start, end = 0, distance
    rocks.sort()
    rocks.append(distance)

    while start <= end:
        mid = (start + end) // 2
        pre_stone_location = 0
        del_stone_count = 0

        for rock in rocks:
            # 현재 위치에서 이전 위치를 뺀 값이 임의 값보다 작다면 임의 값이 최소 값이 아니라는 뜻이므로,
            # 현재 위치를 제거해 해당 구간을 늘려준다면 임의 값이 최소 값이 되기 때문에 현재 위치를 삭제하는 것
            if rock - pre_stone_location < mid:
                del_stone_count += 1

            else:
                pre_stone_location = rock

        # 임의로 설정한 최소 값이 너무 크다는 뜻
        if del_stone_count > n:
            end = mid - 1

        # 질문하기 참고 - 바위를 최대 n개까지 지울 수 있다로 가정하고 풀어야 풀린다.
        # 그니까 무조건 n 개의 바위를 지웠을 때 값이 정답이 아님 ;; 지문이 이상함..

        elif del_stone_count <= n:
            start = mid + 1
            answer = max(answer, mid)

    return answer


print(solution(25, [2, 14, 11, 21, 17], 2))


# 무엇을 기준으로 잡아야하는가 ?
# 구해야하는 것 : n 개의 바위를 제거했을 때 각 바위의 간격 중 최대 값
# n 개의 바위를 제거한 뒤 각 거리를 비교해 최대 값을 구하는 방법 (10억이기 때문에 불가능)
# 바위를 하나 씩 지우고 현재 구간의 최소값을 구해 구해야하는 임의의 값과 비교하는데, (해당 구간을 계산했을 때 최소 값인지 확인하는 것)

# 현재 임의 값이 각 바위의 간격 중 최소 간격 값이라고 가정한 뒤,
# 출발지에서 현재 바위까지의 거리를 뺀 값이 임의의 최소 값보다 작다면,
# 임의 값이 최소 값이 아니라는 뜻이므로 현재 바위를 삭제한다.
# 출발지에서 현재 바위까지 거리를 뺀 값이 임의의 최소 값보다 크다면,
# 임의 값이 아직 최소 값이라는 뜻이므로 출발지를 현재 바위로 옮긴다.
# (출발지를 유지하게 된다면 뒤로 갈 수록 값은 차이가 커지니 비교가 무의미하기 때문)

# 몇 개의 바위를 제거했는지 갱신된 변수 값을 체크하는데,
# 만약 n 개보다 많이 지웠다면 바위를 너무 많이 제거한 것이므로 임의 값을 줄인다.
# 그게 아니라면 현재 최소 값을 갱신하고 임의 값을 늘린다.
# 이렇게 하면, 바위를 제거했을 때 최소 값이 무엇인가 ? 가 아니라 최소 값이 임의 값일 때 바위를 몇 개 지욼 수 있나? 로 관점이 바뀐다.